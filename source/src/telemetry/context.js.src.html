<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>context.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;context.js&quot;,&quot;src/telemetry/context.js&quot;,[null,&quot;/**&quot;,&quot; * Bloombox Telemetry: Context&quot;,&quot; *&quot;,&quot; * @fileoverview Provides tools for detecting, specifying, and merging event&quot;,&quot; * contexts.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.require(&#39;bloombox.VERSION&#39;);&quot;,&quot;goog.require(&#39;bloombox.config.active&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.util.Exportable&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.Serializable&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.b64&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.generateUUID&#39;);&quot;,null,&quot;goog.require(&#39;goog.labs.userAgent.device&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent.platform&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent.product&#39;);&quot;,null,&quot;goog.require(&#39;proto.analytics.Context&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.Scope&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.BrowserDeviceContext&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.Collection&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.DeviceApplication&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.DeviceLibrary&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.DeviceOS&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.DeviceType&#39;);&quot;,&quot;goog.require(&#39;proto.analytics.context.OSType&#39;);&quot;,&quot;goog.require(&#39;proto.commerce.OrderKey&#39;);&quot;,&quot;goog.require(&#39;proto.identity.UserKey&#39;);&quot;,&quot;goog.require(&#39;proto.partner.PartnerDeviceKey&#39;);&quot;,&quot;goog.require(&#39;proto.partner.PartnerKey&#39;);&quot;,&quot;goog.require(&#39;proto.partner.PartnerLocationKey&#39;);&quot;,&quot;goog.require(&#39;proto.structs.VersionSpec&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.Collection&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.Context&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.ContextException&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.buildBrowserContext&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.globalContext&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.resolveFingerprint&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.resolveSessionID&#39;);&quot;,null,null,&quot;// - Event Collections - //&quot;,&quot;/**&quot;,&quot; * Named event collection.&quot;,&quot; *&quot;,&quot; * @param {string} name Name for this collection.&quot;,&quot; * @param {boolean=} opt_skipb64encode Whether to skip base64 encoding. Pass as&quot;,&quot; *        truthy when the collection name is already base64 encoded.&quot;,&quot; * @constructor&quot;,&quot; * @implements {bloombox.util.Exportable&lt;proto.analytics.context.Collection&gt;}&quot;,&quot; * @implements {bloombox.util.Serializable}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Collection = function Collection(name, opt_skipb64encode) {&quot;,&quot;  /**&quot;,&quot;   * Name for this collection.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @export&quot;,&quot;   */&quot;,&quot;  this.name = opt_skipb64encode ? name : bloombox.util.b64.encode(name);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Static method to construct a `Collection` with an arbitrary string name.&quot;,&quot; *&quot;,&quot; * @param {string} name Name for this collection.&quot;,&quot; * @return {bloombox.telemetry.Collection} Constructed collection.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Collection.named = function(name) {&quot;,&quot;  return new bloombox.telemetry.Collection(name);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Export this `Collection` as an `analytics.Collection` message.&quot;,&quot; *&quot;,&quot; * @return {proto.analytics.context.Collection} JS PB message.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Collection.prototype.export = function() {&quot;,&quot;  let collection = new proto.analytics.context.Collection();&quot;,&quot;  collection.setName(this.name);&quot;,&quot;  return collection;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Render this collection object into a JSON-serializable structure suitable for&quot;,&quot; * use over-the-wire.&quot;,&quot; *&quot;,&quot; * @return {Object}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Collection.prototype.serialize = function() {&quot;,&quot;  return {&quot;,&quot;    &#39;name&#39;: this.name&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;// - Master Context - //&quot;,&quot;/**&quot;,&quot; * Indicates an error happened while building or merging event context.&quot;,&quot; *&quot;,&quot; * @param {string} message Error message for the exception.&quot;,&quot; * @constructor&quot;,&quot; */&quot;,&quot;bloombox.telemetry.ContextException = function ContextException(message) {&quot;,&quot;  /**&quot;,&quot;   * Exception message.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.message = message;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gathered event context.&quot;,&quot; *&quot;,&quot; * @param {?bloombox.telemetry.Collection=} opt_collection Collection to file&quot;,&quot; *        this event against.&quot;,&quot; * @param {?string=} opt_partner Partner code to apply to this context.&quot;,&quot; * @param {?string=} opt_location Location code to apply to this context.&quot;,&quot; * @param {?string=} opt_fingerprint Unique device UUID for the active device.&quot;,&quot; * @param {?string=} opt_session Unique session UUID for the active session.&quot;,&quot; * @param {?string=} opt_user Optional. User key to apply to this context.&quot;,&quot; * @param {?string=} opt_device Optional. Device key to apply to this context.&quot;,&quot; *        This is different from the device fingerprint, in that it uniquely&quot;,&quot; *        identifies a known device, rather than being a generic opaque token&quot;,&quot; *        that distinguishes one device context from another.&quot;,&quot; * @param {?string=} opt_order Optional. Order key to apply to this context.&quot;,&quot; * @param {proto.analytics.context.BrowserDeviceContext=} opt_browser Optional.&quot;,&quot; *        Explicit browser device context info to override whatever&quot;,&quot; *        globally-gathered info would normally be sent. When generating global&quot;,&quot; *        context, this property is specified as the detected info.&quot;,&quot; * @constructor&quot;,&quot; * @implements {bloombox.util.Exportable&lt;proto.analytics.Context&gt;}&quot;,&quot; * @implements {bloombox.util.Serializable}&quot;,&quot; * @throws {bloombox.telemetry.ContextException}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Context = function(opt_collection,&quot;,&quot;                                      opt_partner,&quot;,&quot;                                      opt_location,&quot;,&quot;                                      opt_fingerprint,&quot;,&quot;                                      opt_session,&quot;,&quot;                                      opt_user,&quot;,&quot;                                      opt_device,&quot;,&quot;                                      opt_order,&quot;,&quot;                                      opt_browser) {&quot;,&quot;  /**&quot;,&quot;   * Collection to apply this event to.&quot;,&quot;   *&quot;,&quot;   * @type {?bloombox.telemetry.Collection}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.collection = opt_collection || null;&quot;,null,&quot;  /**&quot;,&quot;   * Unique fingerprint for this device context. Always present.&quot;,&quot;   *&quot;,&quot;   * @type {?string}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.fingerprint = opt_fingerprint || null;&quot;,null,&quot;  /**&quot;,&quot;   * Session ID for this user/browser session context.&quot;,&quot;   *&quot;,&quot;   * @type {?string}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.session = opt_session || null;&quot;,null,&quot;  // make us a partner key&quot;,&quot;  let partnerKey;&quot;,&quot;  if (opt_partner) {&quot;,&quot;    partnerKey = new proto.partner.PartnerKey();&quot;,&quot;    partnerKey.setCode(opt_partner);&quot;,&quot;  } else {&quot;,&quot;    partnerKey = null;&quot;,&quot;  }&quot;,null,&quot;  // make us a partner key&quot;,&quot;  let locationKey;&quot;,&quot;  if (opt_partner &amp;&amp; opt_location) {&quot;,&quot;    locationKey = new proto.partner.PartnerLocationKey();&quot;,&quot;    locationKey.setCode(opt_location);&quot;,&quot;    locationKey.setPartner(partnerKey);&quot;,&quot;  } else if (opt_partner &amp;&amp; opt_location) {&quot;,&quot;    // failure: must specify a partner to specify a location&quot;,&quot;    throw new bloombox.telemetry.ContextException(&quot;,&quot;      &#39;Cannot provide location context without partner context.&#39;);&quot;,&quot;  } else {&quot;,&quot;    // no location-level context&quot;,&quot;    locationKey = null;&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * Location code.&quot;,&quot;   *&quot;,&quot;   * @type {?proto.partner.PartnerLocationKey}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.location = locationKey;&quot;,null,&quot;  // device the device key, if any&quot;,&quot;  let deviceKey;&quot;,&quot;  if (opt_device &amp;&amp; typeof opt_device === &#39;string&#39;) {&quot;,&quot;    deviceKey = new proto.partner.PartnerDeviceKey();&quot;,&quot;    deviceKey.setUuid(/** @type {string} */ (opt_device));&quot;,&quot;    deviceKey.setLocation(locationKey);&quot;,&quot;  } else {&quot;,&quot;    deviceKey = null;&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * Known device key or UUID to attribute this event to. Defaults to `null`,&quot;,&quot;   * indicating an anonymous device, like a user&#39;s browser.&quot;,&quot;   *&quot;,&quot;   * @type {?proto.partner.PartnerDeviceKey}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.device = deviceKey;&quot;,null,&quot;  // decode the user key, if any&quot;,&quot;  let user;&quot;,&quot;  if (opt_user) {&quot;,&quot;    let userKey = new proto.identity.UserKey();&quot;,&quot;    userKey.setUid(opt_user);&quot;,&quot;    user = userKey;&quot;,&quot;  } else {&quot;,&quot;    user = null;&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * User key to attribute this event to. Defaults to `null`, indicating no&quot;,&quot;   * currently-active user.&quot;,&quot;   *&quot;,&quot;   * @type {?proto.identity.UserKey}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.user = user;&quot;,null,&quot;  // decode the order key, if any&quot;,&quot;  let order;&quot;,&quot;  if (opt_order) {&quot;,&quot;    let orderKey = new proto.commerce.OrderKey();&quot;,&quot;    orderKey.setId(opt_order);&quot;,&quot;    order = orderKey;&quot;,&quot;  } else {&quot;,&quot;    order = null;&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * Order key to attribute this event to. Defaults to `null`, indicating no&quot;,&quot;   * currently-active order.&quot;,&quot;   *&quot;,&quot;   * @type {?proto.commerce.OrderKey}&quot;,&quot;   */&quot;,&quot;  this.order = order;&quot;,null,&quot;  // attach browser context, if any&quot;,&quot;  /**&quot;,&quot;   * Browser context, if any, or `null`.&quot;,&quot;   * @type {?proto.analytics.context.BrowserDeviceContext}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.browser = opt_browser || null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Serialize the protobuf form of a version specification.&quot;,&quot; *&quot;,&quot; * @param {proto.structs.VersionSpec} protob Version spec.&quot;,&quot; * @return {Object} Serialized version spec.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Context.resolveVersion = function(protob) {&quot;,&quot;  if (protob &amp;&amp; protob.getName())&quot;,&quot;    return {&quot;,&quot;      &#39;name&#39;: protob.getName()&quot;,&quot;    };&quot;,&quot;  return {};&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Serialize the protobuf form of local browser context, into an object usable&quot;,&quot; * over-the-wire.&quot;,&quot; *&quot;,&quot; * @param {proto.analytics.context.BrowserDeviceContext} protob Browser context.&quot;,&quot; * @return {Object} Serialized browser context.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Context.serializeBrowserContext = function(protob) {&quot;,&quot;  return {&quot;,&quot;    &#39;browserType&#39;: protob.getBrowserType(),&quot;,&quot;    &#39;deviceType&#39;: protob.getDeviceType(),&quot;,&quot;    &#39;version&#39;: bloombox.telemetry.Context.resolveVersion(protob.getVersion()),&quot;,&quot;    &#39;os&#39;: {&quot;,&quot;      &#39;type&#39;: protob.getOs().getType(),&quot;,&quot;      &#39;version&#39;: (&quot;,&quot;        bloombox.telemetry.Context.resolveVersion(protob.getOs().getVersion()))&quot;,&quot;    },&quot;,&quot;    &#39;app&#39;: {&quot;,&quot;      &#39;type&#39;: protob.getApp().getType(),&quot;,&quot;      &#39;origin&#39;: protob.getApp().getOrigin()&quot;,&quot;    },&quot;,&quot;    &#39;library&#39;: {&quot;,&quot;      &#39;variant&#39;: protob.getLibrary().getVariant(),&quot;,&quot;      &#39;version&#39;: (&quot;,&quot;        bloombox.telemetry.Context.resolveVersion(&quot;,&quot;          protob.getLibrary().getVersion()))&quot;,&quot;    }&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Render a protobuf message representing this context, into a native JavaScript&quot;,&quot; * object that is suitable for transmission over-the-wire.&quot;,&quot; *&quot;,&quot; * @param {proto.analytics.Context} context Context proto to render.&quot;,&quot; * @return {Object} Serialized version of the proto object.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Context.serializeProto = function(context) {&quot;,&quot;  let baseContext = {};&quot;,null,&quot;  // string data&quot;,&quot;  if (context.getCollection() &amp;&amp; context.getCollection().getName())&quot;,&quot;    baseContext[&#39;collection&#39;] = {&#39;name&#39;: context.getCollection().getName()};&quot;,&quot;  if (context.getFingerprint())&quot;,&quot;    baseContext[&#39;fingerprint&#39;] = context.getFingerprint();&quot;,&quot;  if (context.getGroup())&quot;,&quot;    baseContext[&#39;group&#39;] = context.getGroup();&quot;,null,&quot;  // key contexts&quot;,&quot;  if (context.getUser() &amp;&amp; context.getUser().getUid())&quot;,&quot;    baseContext[&#39;user&#39;] = {&#39;uid&#39;: context.getUser().getUid()};&quot;,null,&quot;  // handle partner/commercial scope&quot;,&quot;  if (context.getScope()) {&quot;,&quot;    let scopeObj = {};&quot;,&quot;    if (context.getScope().getPartner()) {&quot;,&quot;      scopeObj[&#39;partner&#39;] = context.getScope().getPartner();&quot;,&quot;    }&quot;,null,&quot;    if (context.getScope().getCommercial()) {&quot;,&quot;      scopeObj[&#39;commercial&#39;] = context.getScope().getCommercial();&quot;,&quot;    }&quot;,&quot;    baseContext[&#39;scope&#39;] = scopeObj;&quot;,&quot;  }&quot;,null,&quot;  // setup browser context&quot;,&quot;  switch (context.getDeviceContextCase()) {&quot;,&quot;    case proto.analytics.Context.DeviceContextCase.BROWSER:&quot;,&quot;      // browser is set&quot;,&quot;      baseContext[&#39;browser&#39;] = (&quot;,&quot;        bloombox.telemetry.Context.serializeBrowserContext(&quot;,&quot;          context.getBrowser()));&quot;,&quot;      break;&quot;,&quot;    default:&quot;,&quot;      // it is unset: just continue onwards&quot;,&quot;      break;&quot;,&quot;  }&quot;,&quot;  return baseContext;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Render this context object into a JSON-serializable structure suitable for&quot;,&quot; * use over-the-wire.&quot;,&quot; *&quot;,&quot; * @return {Object}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Context.prototype.serialize = function() {&quot;,&quot;  let baseContext = {};&quot;,null,&quot;  // add collection, if present&quot;,&quot;  if (this.collection)&quot;,&quot;    baseContext[&#39;collection&#39;] = this.collection.serialize();&quot;,null,&quot;  // add fingerprint, if present&quot;,&quot;  if (this.fingerprint)&quot;,&quot;    baseContext[&#39;fingerprint&#39;] = this.fingerprint;&quot;,null,&quot;  // add session key, if present&quot;,&quot;  if (this.session)&quot;,&quot;    baseContext[&#39;group&#39;] = this.session;&quot;,null,&quot;  // add user key, if present&quot;,&quot;  if (this.user)&quot;,&quot;    baseContext[&#39;user&#39;] = {&quot;,&quot;      &#39;uid&#39;: this.user.getUid()&quot;,&quot;    };&quot;,null,&quot;  // add order key, if present&quot;,&quot;  if (this.order)&quot;,&quot;    baseContext[&#39;order&#39;] = {&quot;,&quot;      &#39;id&#39;: this.order.getId()&quot;,&quot;    };&quot;,null,&quot;  // consider partner context, etc&quot;,&quot;  let partnerScope = /** @type {?string} */ (null);&quot;,null,&quot;  if (this.location) {&quot;,&quot;    if (this.device) {&quot;,&quot;      partnerScope = [&quot;,&quot;        this.location.getPartner().getCode(),&quot;,&quot;        this.location.getCode(),&quot;,&quot;        this.device.getUuid()].join(&#39;/&#39;);&quot;,&quot;    } else {&quot;,&quot;      partnerScope = [&quot;,&quot;        this.location.getPartner().getCode(),&quot;,&quot;        this.device.getUuid()].join(&#39;/&#39;);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    if (this.partner) {&quot;,&quot;      partnerScope = this.location.getPartner().getCode();&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  if (partnerScope)&quot;,&quot;    baseContext[&#39;scope&#39;] = {&quot;,&quot;      &#39;partner&#39;: partnerScope&quot;,&quot;    };&quot;,null,&quot;  // consider commercial context&quot;,&quot;  // @TODO: section and product key for commercial scope&quot;,&quot;  if (this.order) {&quot;,&quot;    if (!baseContext[&#39;scope&#39;]) {&quot;,&quot;      baseContext[&#39;scope&#39;] = {&quot;,&quot;        &#39;order&#39;: this.order.getId()&quot;,&quot;      };&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // consider browser context&quot;,&quot;  if (this.browser)&quot;,&quot;    baseContext[&#39;browser&#39;] = (&quot;,&quot;      bloombox.telemetry.Context.serializeBrowserContext(this.browser));&quot;,&quot;  return baseContext;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Export the current analytics context as a protobuf message.&quot;,&quot; *&quot;,&quot; * @return {proto.analytics.Context}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Context.prototype.export = function() {&quot;,&quot;  let context = new proto.analytics.Context();&quot;,null,&quot;  // attach required client context, and group by session&quot;,&quot;  if (this.fingerprint) context.setFingerprint(this.fingerprint);&quot;,&quot;  if (this.session) context.setGroup(this.session);&quot;,null,&quot;  // attach misc context&quot;,&quot;  if (this.collection) context.setCollection(this.collection.export());&quot;,&quot;  if (this.user) context.setUser(this.user);&quot;,null,&quot;  let scope = new proto.analytics.Scope();&quot;,null,&quot;  // calculate partner context&quot;,&quot;  if (this.location) {&quot;,&quot;    if (this.device) {&quot;,&quot;      // full device-&gt;location-&gt;partner context&quot;,&quot;      scope.setPartner(&quot;,&quot;        &#39;partner/&#39; + this.location.getPartner().getCode() +&quot;,&quot;        &#39;location/&#39; + this.location.getCode() +&quot;,&quot;        &#39;device/&#39; + this.device.getUuid());&quot;,&quot;    } else {&quot;,&quot;      // partner -&gt; location context&quot;,&quot;      scope.setPartner(&quot;,&quot;        &#39;partner/&#39; + this.location.getPartner().getCode() +&quot;,&quot;        &#39;location/&#39; + this.location.getCode());&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // device context&quot;,&quot;  if (this.browser) context.setBrowser(this.browser);&quot;,&quot;  return context;&quot;,&quot;};&quot;,null,null,&quot;// - Global Context - //&quot;,&quot;/**&quot;,&quot; * Globally-cached context singleton for values that are detected or loaded or&quot;,&quot; * computed expensively by the runtime. Merged into event-level context before&quot;,&quot; * events are sent.&quot;,&quot; *&quot;,&quot; * @type {?bloombox.telemetry.Context}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GLOBAL_CONTEXT = null;&quot;,null,null,&quot;/**&quot;,&quot; * Globally-cached unique fingerprint for this device. Persisted in local&quot;,&quot; * browser storage. Null means it is not yet initialized.&quot;,&quot; *&quot;,&quot; * @type {?string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.DEVICE_FINGERPRINT = null;&quot;,null,null,&quot;/**&quot;,&quot; * Session-scoped token to indicate the border between different user sessions.&quot;,&quot; * Leverages session storage instead of local storage. Null means it is not yet&quot;,&quot; * initialized.&quot;,&quot; *&quot;,&quot; * @type {?string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.SESSION_ID = null;&quot;,null,null,&quot;/**&quot;,&quot; * The key used in local storage to locally fingerprint a web browser-based&quot;,&quot; * device.&quot;,&quot; *&quot;,&quot; * @const {string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.DEVICE_FINGERPRINT_KEY = &#39;bb:v1:t.df&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * The key used in session storage to indicate the session ID.&quot;,&quot; *&quot;,&quot; * @const {string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.SESSION_ID_KEY = &#39;bb:v1:t.sid&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Resolve the device fingerprint, by creating it if it does not yet exist, or&quot;,&quot; * returning the existing one if it does.&quot;,&quot; *&quot;,&quot; * @return {string} Global device fingerprint.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.resolveFingerprint = function() {&quot;,&quot;  if (bloombox.telemetry.DEVICE_FINGERPRINT === null) {&quot;,&quot;    // try to fetch it from local storage&quot;,&quot;    let existingFingerprint = (&quot;,&quot;     window.localStorage.getItem(bloombox.telemetry.DEVICE_FINGERPRINT_KEY));&quot;,null,&quot;    if (existingFingerprint &amp;&amp; typeof existingFingerprint === &#39;string&#39;) {&quot;,&quot;      // we found it, load the existing one from local storage&quot;,&quot;      bloombox.telemetry.DEVICE_FINGERPRINT = existingFingerprint;&quot;,&quot;    } else {&quot;,&quot;      // we could not find one in local storage. generate one, persist it&quot;,&quot;      // in local storage and locally, and return.&quot;,&quot;      let newDeviceFingerprint = bloombox.util.generateUUID();&quot;,&quot;      bloombox.telemetry.DEVICE_FINGERPRINT = newDeviceFingerprint;&quot;,&quot;      window.localStorage.setItem(&quot;,&quot;        bloombox.telemetry.DEVICE_FINGERPRINT_KEY, newDeviceFingerprint);&quot;,&quot;      bloombox.logging.log(&#39;Established device fingerprint: \&quot;&#39; +&quot;,&quot;        newDeviceFingerprint + \&quot;&#39;.\&quot;);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.DEVICE_FINGERPRINT;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve the session ID, by creating it if it does not yet exist, or returning&quot;,&quot; * the existing one if it does.&quot;,&quot; *&quot;,&quot; * @return {string} Session-scoped UUID.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.resolveSessionID = function() {&quot;,&quot;  if (bloombox.telemetry.SESSION_ID === null) {&quot;,&quot;    // try to fetch it from local storage&quot;,&quot;    let existingID = (&quot;,&quot;      window.sessionStorage.getItem(bloombox.telemetry.SESSION_ID_KEY));&quot;,null,&quot;    if (existingID &amp;&amp; typeof existingID === &#39;string&#39;) {&quot;,&quot;      // we found it, load the existing one from local storage&quot;,&quot;      bloombox.telemetry.SESSION_ID = existingID;&quot;,&quot;    } else {&quot;,&quot;      // we could not find one in local storage. generate one, persist it&quot;,&quot;      // in local storage and locally, and return.&quot;,&quot;      let newSessionID = bloombox.util.generateUUID();&quot;,&quot;      bloombox.telemetry.SESSION_ID = newSessionID;&quot;,&quot;      window.sessionStorage.setItem(&quot;,&quot;        bloombox.telemetry.SESSION_ID_KEY, newSessionID);&quot;,&quot;      bloombox.logging.log(&#39;Established user session at ID: \&quot;&#39; +&quot;,&quot;        newSessionID + \&quot;&#39;.\&quot;);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.SESSION_ID;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Build local browser context from the available environment.&quot;,&quot; *&quot;,&quot; * @return {proto.analytics.context.BrowserDeviceContext}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.buildBrowserContext = function() {&quot;,&quot;  let context = new proto.analytics.context.BrowserDeviceContext();&quot;,null,&quot;  // detect browser type and version&quot;,&quot;  let browserVersion = goog.userAgent.VERSION;&quot;,&quot;  let browserType = (&quot;,&quot;    proto.analytics.context.BrowserType.BROWSER_UNKNOWN);&quot;,&quot;  if (goog.userAgent.product.CHROME)&quot;,&quot;    browserType = (&quot;,&quot;      proto.analytics.context.BrowserType.CHROME);&quot;,&quot;  else if (goog.userAgent.product.SAFARI)&quot;,&quot;    browserType = (&quot;,&quot;      proto.analytics.context.BrowserType.SAFARI);&quot;,&quot;  else if (goog.userAgent.product.FIREFOX)&quot;,&quot;    browserType = (&quot;,&quot;      proto.analytics.context.BrowserType.FIREFOX);&quot;,&quot;  else if (goog.userAgent.product.OPERA)&quot;,&quot;    browserType = (&quot;,&quot;      proto.analytics.context.BrowserType.OPERA);&quot;,&quot;  else if (goog.userAgent.EDGE_OR_IE)&quot;,&quot;    browserType = (&quot;,&quot;      proto.analytics.context.BrowserType.IE_OR_EDGE);&quot;,&quot;  context.setBrowserType(browserType);&quot;,null,&quot;  // detect device type&quot;,&quot;  let deviceType = proto.analytics.context.DeviceType.UNKNOWN_DEVICE_TYPE;&quot;,&quot;  if (goog.labs.userAgent.device.isDesktop)&quot;,&quot;    deviceType = proto.analytics.context.DeviceType.DESKTOP;&quot;,&quot;  else if (goog.labs.userAgent.device.isTablet)&quot;,&quot;    deviceType = proto.analytics.context.DeviceType.TABLET;&quot;,&quot;  else if (goog.labs.userAgent.device.isMobile)&quot;,&quot;    deviceType = proto.analytics.context.DeviceType.PHONE;&quot;,&quot;  context.setDeviceType(deviceType);&quot;,null,&quot;  let browserVersionObj = new proto.structs.VersionSpec();&quot;,&quot;  browserVersionObj.setName(browserVersion);&quot;,&quot;  context.setVersion(browserVersionObj);&quot;,null,&quot;  // detect OS type and version&quot;,&quot;  let osType = proto.analytics.context.OSType.OS_UNKNOWN;&quot;,&quot;  let osVersion = goog.userAgent.platform.VERSION;&quot;,null,&quot;  if (goog.userAgent.IPAD ||&quot;,&quot;      goog.userAgent.IPHONE ||&quot;,&quot;      goog.userAgent.IPOD ||&quot;,&quot;      goog.userAgent.IOS)&quot;,&quot;    osType = proto.analytics.context.OSType.IOS;&quot;,&quot;  else if ((goog.userAgent.WINDOWS ||&quot;,&quot;            goog.userAgent.EDGE_OR_IE) &amp;&amp;&quot;,&quot;            goog.userAgent.MOBILE)&quot;,&quot;    osType = proto.analytics.context.OSType.WINDOWS_PHONE;&quot;,&quot;  else if (goog.userAgent.WINDOWS ||&quot;,&quot;           goog.userAgent.EDGE_OR_IE)&quot;,&quot;    osType = proto.analytics.context.OSType.WINDOWS;&quot;,&quot;  else if (goog.userAgent.product.ANDROID)&quot;,&quot;    osType = proto.analytics.context.OSType.ANDROID;&quot;,&quot;  else if (goog.userAgent.MAC)&quot;,&quot;    osType = proto.analytics.context.OSType.MACOS;&quot;,&quot;  else if (goog.userAgent.LINUX)&quot;,&quot;    osType = proto.analytics.context.OSType.LINUX;&quot;,null,&quot;  let osObj = new proto.analytics.context.DeviceOS();&quot;,&quot;  let osVersionObj = new proto.structs.VersionSpec();&quot;,&quot;  osVersionObj.setName(osVersion);&quot;,&quot;  osObj.setType(osType);&quot;,&quot;  osObj.setVersion(osVersionObj);&quot;,&quot;  context.setOs(osObj);&quot;,null,&quot;  // detect application type and version&quot;,&quot;  let origin = window.document[&#39;origin&#39;];&quot;,&quot;  let app = new proto.analytics.context.DeviceApplication();&quot;,&quot;  app.setOrigin(origin);&quot;,&quot;  context.setApp(app);&quot;,null,&quot;  // detect library type and version&quot;,&quot;  let libraryVersion = bloombox.VERSION;&quot;,&quot;  let libraryVariant = bloombox.VARIANT;&quot;,null,&quot;  let libObj = new proto.analytics.context.DeviceLibrary();&quot;,&quot;  let libVersionObj = new proto.structs.VersionSpec();&quot;,&quot;  libVersionObj.setName(libraryVersion);&quot;,&quot;  libObj.setVersion(libVersionObj);&quot;,&quot;  libObj.setVariant(libraryVariant);&quot;,&quot;  context.setLibrary(libObj);&quot;,null,&quot;  return context;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve globally gathered/specified context. Caching is applied to reduce&quot;,&quot; * overhead. To force a re-gather of expensively calculated information, pass&quot;,&quot; * `opt_force_fresh` as truthy.&quot;,&quot; *&quot;,&quot; * @param {boolean=} opt_force_fresh Force a fresh load of global context.&quot;,&quot; * @return {bloombox.telemetry.Context} Global context.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.globalContext = function(opt_force_fresh) {&quot;,&quot;  let forceFresh = opt_force_fresh || false;&quot;,&quot;  if (bloombox.telemetry.GLOBAL_CONTEXT === null || forceFresh) {&quot;,&quot;    // grab global config&quot;,&quot;    let config = bloombox.config.active();&quot;,&quot;    let partnerCode = config.partner || null;&quot;,&quot;    let locationCode = config.location || null;&quot;,&quot;    let deviceFingerprint = bloombox.telemetry.resolveFingerprint();&quot;,&quot;    let sessionID = bloombox.telemetry.resolveSessionID();&quot;,&quot;    let browserContext = bloombox.telemetry.buildBrowserContext();&quot;,null,&quot;    // calculate global context&quot;,&quot;    bloombox.telemetry.GLOBAL_CONTEXT = new bloombox.telemetry.Context(&quot;,&quot;      null,&quot;,&quot;      partnerCode,&quot;,&quot;      locationCode,&quot;,&quot;      deviceFingerprint,&quot;,&quot;      sessionID,&quot;,&quot;      null,  // @TODO: ability to use logged-in user&quot;,&quot;      null,  // @TODO: ability to use active device&quot;,&quot;      null,  // @TODO: ability to use active order&quot;,&quot;      browserContext);&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.GLOBAL_CONTEXT;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../dossier.js" defer></script>